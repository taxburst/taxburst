{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"taxburst documentation","text":"<p>taxburst is a fork of the Krona software (Ondov, Bergman, and Philippy, 2011). It produces static HTML pages that provide an interactive display of a metagenomic taxonomy.</p> <p>The goal of taxburst is to update Krona to a maintained, documented piece of software that can be adapted and adjusted in a variety of ways.  This is still beta mode software, to be used at your own risk.</p> <p>Here is an example screenshot:</p> <p></p>"},{"location":"#input-formats","title":"Input formats","text":"<p>taxburst v0.3.0 (Aug 2025) has parsers for the following formats:</p> <ul> <li>sourmash <code>tax annotate</code> and <code>csv_summary</code> outputs;</li> <li>SingleM profile output;</li> <li>Krona format;</li> <li>nested dictionaries in JSON;</li> </ul> <p>Please file an issue if you need support for an additional format!</p>"},{"location":"#support-and-help","title":"Support and help","text":"<p>Please file bugs and feature requests on the issue tracker.</p> <p>Pull requests are welcome!</p>"},{"location":"#examples","title":"Examples","text":"<p>Here are some examples of (interactive!) taxburst plots:</p> <ul> <li>SRR11125891.SingleM.html - displaying the results of <code>singlem pipe</code> on SRR11125891, a pig gut microbiome.</li> <li>SRR11125891.summarized.html - <code>sourmash</code> taxonomic breakdown on SRR11125891.</li> <li>SRR11125891.tax_annotate.html - genome-resolution taxonomic breakdown of SRR11125891.</li> <li>SRR11125891.krona.html - krona-format input parsing output (produced by <code>sourmash tax metagenome</code>).</li> </ul> <p>The input formats behind these taxburst plots can be found in <code>examples/</code> folder in the top level of the git repo.  The README in that directory contains some minimal documentation on how the examples were created.</p>"},{"location":"#install","title":"Install","text":"<p>taxburst is available on the Python Package Index (PyPI) under pypi.org/project/taxburst.</p> <p>To install it, run:</p> <pre><code>pip install taxburst\n</code></pre> <p>It is also available on Bioconda.</p> <pre><code>conda create -n taxburst -c bioconda taxburst\nconda activate taxburst\n</code></pre>"},{"location":"#authors","title":"Authors","text":"<p>The original Krona software was developed by Brian Ondov, Nicholas Bergman, and Adam Philippy.</p> <p>taxburst is developed by Titus Brown. The HTML format is largely unchanged, but the parsing front-end and output mechanisms have been completely rewritten in Python, and enhanced output validation has been added.</p> <p>You can contact Titus at ctbrown@ucdavis.edu if needed, but please use the issue tracker as much as possible :).</p>"},{"location":"#citation-information","title":"Citation information","text":"<p>When using taxburst, please cite the Krona paper: Interactive metagenomic visualization in a Web browser, Ondov et al., 2011.</p>"},{"location":"command-line/","title":"Command-line docs for taxburst","text":""},{"location":"command-line/#basic-usage","title":"Basic usage","text":"<p>The basic usage for taxburst is simple:</p> <pre><code>taxburst -F &lt;format&gt; &lt;input_file&gt; -o &lt;output.HTML&gt;\n</code></pre> <p>The following input formats are supported:</p> <ul> <li><code>tax_annotate</code>: a sourmash file produced by running  <code>sourmash tax annotate</code> on the output of <code>sourmash gather</code>. This is the recommended sourmash format.</li> <li><code>csv_summary</code>: a sourmash file produced by running <code>sourmash tax metagenome</code> on the output of <code>sourmash gather</code>.</li> <li><code>SingleM</code>: the profile TSV output by <code>singlem pipe ... -p &lt;output.tsv&gt;</code>.</li> <li><code>krona</code>: a krona-format TSV file.</li> <li><code>json</code>: a list of nested dictionaries, in JSON format; see below for details.</li> </ul>"},{"location":"command-line/#formats-counts-and-scores","title":"Formats, counts, and scores","text":""},{"location":"command-line/#tax_annotate","title":"<code>tax_annotate</code>","text":"<p>The <code>-F tax_annotate</code> format will take in sourmash gather results annotated with <code>sourmash tax annotate</code>. The resulting counts in the taxburst display will be the weighted number of hashes matching at each taxonomic level; multiply this by the scaled factor used in sourmash to get an estimate of the bp in the original metagenome.</p> <p>This format is the preferred sourmash format because it supports assignments down to the genome level, while <code>sourmash tax metagenome</code>'s <code>csv_summary</code> format only goes down to the species level.</p>"},{"location":"command-line/#csv_summary","title":"<code>csv_summary</code>","text":"<p>The <code>-F csv_summary</code> format will take in the results of <code>sourmash tax metagenome</code> run with <code>-F csv_summary</code>. The counts produced for taxburst are 1000 times the <code>f_weighted_at_rank</code> value.</p>"},{"location":"command-line/#singlem","title":"<code>SingleM</code>","text":"<p>The <code>-F SingleM</code> format will take in the results of <code>singlem pipe -p</code>, a profile TSV file. The count reported by taxburst is 1000 x the <code>coverage</code> column.</p> <pre><code>sample  coverage        taxonomy\nSRR11125891_1   0.48    Root; d__Archaea\nSRR11125891_1   1.73    Root; d__Bacteria\nSRR11125891_1   2.21    Root; d__Bacteria; p__Bacillota\nSRR11125891_1   0.05    Root; d__Bacteria; p__Pseudomonadota\nSRR11125891_1   0.17    Root; d__Bacteria; p__Verrucomicrobiota\nSRR11125891_1   2.89    Root; d__Bacteria; p__Bacillota; c__Clostridia\nSRR11125891_1   0.56    Root; d__Bacteria; p__Bacillota; c__Bacilli\nSRR11125891_1   0.57    Root; d__Bacteria; p__Bacillota; c__Negativicutes\n</code></pre>"},{"location":"command-line/#krona-format","title":"<code>krona</code> format","text":"<p>The <code>-F krona</code> format will take in a standard Krona-format file. The reported count is 1000 x the <code>fraction</code> column.</p> <pre><code>fraction        superkingdom    phylum  class   order   family  genus   species\n0.06582267833109018     Eukaryota       Chordata        Mammalia        Artiodactyla    Suidae  Sus     Sus scrofa\n0.0259084791386272      d__Bacteria     p__Pseudomonadota       c__Gammaproteobacteria  o__Enterobacterales     f__Enterobacteriaceae   g__Escherichia  s__Escherichia coli\n</code></pre>"},{"location":"command-line/#outputting-json-format","title":"Outputting JSON format","text":"<p>Instead of (or in addition to) an HTML file, taxburst can produce a JSON format with <code>--save-json &lt;output.json&gt;</code>. This format can then be consumed by taxburst with <code>-F json</code>.</p> <p>The JSON format is a list of nested dictionaries:</p> <pre><code>[\n  {\n    \"name\": \"A\",\n    \"count\": 5,\n    \"rank\": \"Phylum\",\n    \"children\": [\n      {\n        \"name\": \"B\",\n        \"count\": 3,\n        \"score\": 0.2,\n        \"rank\": \"Class\"\n      },\n      {\n        \"name\": \"C\",\n        \"count\": 1,\n        \"rank\": \"Class\"\n      }\n    ]\n  }\n]\n</code></pre>"},{"location":"developer/","title":"Information for Developers","text":"<p>Please file issues in the issue tracker if you have questions or comments!</p> <p>Pull requests are welcome!</p>"},{"location":"developer/#guidance-on-writing-new-parsers","title":"Guidance on writing new parsers","text":"<p>The current built-in parsers are contained in <code>src/taxburst/parsers.py</code>.  In general, if you are familiar with Python, the easiest way to proceed is to copy and rename an existing parsing class (e.g. <code>Parse_SourmashCSVSummary</code>) and modify the <code>build</code> method.  Then add a new if/else branch in the top level <code>parse_file</code> method.</p> <p>The current parsers work by creating a <code>nodes_by_tax</code> dictionary that contains (key, value) pairs where each key is a semicolon-separated lineage (e.g. <code>d__Bacteria;p__Spirochaetota</code>) and each value is a \"node dictionary\", a dictionary containing at least <code>name</code>, <code>count</code>, and <code>rank</code>. This dictionary must contain all lineage subpaths - e.g. if there is an entry for <code>d__Bacteria;p__Spirochaetota</code> then there must also be an entry for <code>d__Bacteria</code>.</p> <p>If the <code>nodes_by_tax</code> dictionary is built properly, then the function <code>taxburst.parsers.assign_children</code> will build the hierarchy of nodes needed for conversion into XHTML.</p> <p>Many consistency checks are applied to this tree before output, and additional consistency checks can be run with <code>--check-tree</code> on the taxburst command line. If you find an error that is not caught by these checks, please file an issue about it and we will add it to the checks!</p> <p>An alternative approach to writing a parser is to produce your own set of nested dictionaries in Python, or, if you prefer to program in a different language, write code to output the JSON format (see below).</p>"},{"location":"developer/#examples-documentation-and-automated-testing","title":"Examples, documentation, and automated testing","text":"<p>For each new Python-based format parser, please add an example (ideally, calculated for the metagenome <code>SRR11125891</code>) to the <code>examples/</code> top-level directory, and (ideally) add a step to the snakemake workflow in <code>examples/Snakefile</code> so that taxburst is automatically run on the example. You should also add a link to the example output in the <code>doc/README.md</code> file.</p> <p>Please also add a brief description of the new parser format to the <code>doc/command-line.md</code> document.</p> <p>Last but by no means least, please add a new <code>tests/test_parse_*.py</code> file that runs the parser and checks a few values.</p> <p>If you are writing a parser in another language that outputs JSON, please feel free to include the original file and the JSON output file in the examples, and link to your parsing code in the documentation. Note: for the moment, the JSON format doesn't support custom attribute display; if you need this, please let us know and we'll figure something out!</p> <p>Feel free to ask for help on any of these tasks!p</p>"},{"location":"developer/#additional-points","title":"Additional points","text":"<p>There is no inherent restriction on ranks, although the current parsing classes all inherit from <code>GenericParser</code> which supports the normal NCBI/GTDB ranks from \"superkingdom\" on down. Eventually we want to support custom ranks (LINS, ICTV, etc); drop us a note if you're interested in helping out, or testing!</p> <p>Other keys are allowed in the node dictionary but are ignored in the output format unless an <code>extra_attributes</code> dictionary is returned by the parsing function; see the <code>tax_annotate</code> format parser for an example.</p>"},{"location":"developer/#internals-of-the-input-and-output-formats","title":"Internals of the input and output formats","text":"<p>The taxburst code works in the following stages:</p> <ol> <li>Load in an input file containing some taxonomic summary.</li> <li>Convert that summary into an internal tree format in Python, based on nested lists of dictionaries.</li> <li>Convert that internal tree format into XHTML, which is then saved in a static HTML file with accompanying JavaScript to support interactive visualization.</li> </ol> <p>These two intermediate formats are useful to know about because there are two ways to support new input formats: you can either write a Python function to convert a new format into the internal tree format, or you can write code in any language to output JSON that can be loaded into the internal tree format.</p> <p>taxburst consumes a JSON version of this format with <code>-F json</code>, and produces this format with <code>--save-json &lt;filenam&gt;</code>.</p> <p>(In the future, it should be possible to modify the internal JavaScript in the static HTML file to read the JSON directly, which would simplify this even more and allow for more flexibility as well.)</p>"},{"location":"developer/#internal-dictionary-format","title":"Internal dictionary format","text":"<p>Here is a simple example of the internal dictionary format:</p> <pre><code>nodes = [\n    {\n        \"name\": \"A\",\n        \"count\": 5,\n        \"score\": 0.831,\n        \"rank\": \"Phylum\",\n        \"children\": [\n            {\"name\": \"B\", \"count\": 3, \"score\": 0.2, \"rank\": \"Class\"},\n            {\"name\": \"C\", \"count\": 1, \"score\": 0.1, \"rank\": \"Class\"},\n        ],\n    },\n]\n</code></pre> <p>See <code>examples/simple-output.py</code> in the github repo for example code to produce an output HTML from this.</p>"},{"location":"developer/#json-version-of-the-internal-dictionary-format","title":"JSON version of the internal dictionary format","text":"<p>This nested dictionary format converts to fairly simple JSON:</p> <pre><code>[\n  {\n    \"name\": \"A\",\n    \"count\": 5,\n    \"rank\": \"Phylum\",\n    \"children\": [\n      {\n        \"name\": \"B\",\n        \"count\": 3,\n        \"rank\": \"Class\"\n      },\n      {\n        \"name\": \"C\",\n        \"count\": 1,\n        \"rank\": \"Class\"\n      }\n    ]\n  }\n]\n</code></pre> <p>This can be loaded from a file and converted into an HTML file like so:</p> <pre><code>import json\nimport taxburst\n\nwith open('nodes.json') as fp:\n   nodes = json.load(fp)\n\ncontent = taxburst.generate_html(nodes)\nwith open('nodes.html') as fp:\n   fp.write(content)\n</code></pre> <p>This is equivalent to <code>taxburst -F json nodes.json -o nodes.html</code>.</p>"},{"location":"developer/#output-formatting","title":"Output formatting","text":"<p>taxburst uses Jinja2 templates to provide customizable formatting of the HTML output. Please see the files in src/taxburst/templates/ for implementation.</p>"},{"location":"quickstart/","title":"Quickstart","text":""},{"location":"quickstart/#example-command-lines","title":"Example command lines","text":"<p>All data files are available in the GitHub repository under <code>examples/</code>.</p>"},{"location":"quickstart/#using-sourmash-tax-metagenome-output-summary_csv-format","title":"Using <code>sourmash tax metagenome</code> output - <code>summary_csv</code> format","text":"<p>An example using the summary_csv format from <code>sourmash tax metagenome</code> (see tax metagenome docs),</p> <pre><code>taxburst examples/SRR11125891.summarized.csv \\\n    -o pages/SRR11125891.summarized.html\n</code></pre> <p>then open <code>pages/SRR11125891.summarized.html</code> in a browser.</p>"},{"location":"quickstart/#using-sourmash-tax-annotate-output","title":"Using <code>sourmash tax annotate</code> output","text":"<p>An example using the with-lineages format from <code>sourmash tax annotate</code> (see tax annotate docs</p> <pre><code>taxburst -F tax_annotate \\\n    examples/SRR11125891.t0.gather.with-lineages.csv \\\n    -o pages/SRR11125891.tax_annotate.html\n</code></pre> <p>then open <code>pages/SRR11125891.tax_annotate.html</code> in a browser.</p>"},{"location":"quickstart/#using-singlem-pipe-output","title":"Using <code>singleM pipe</code> output","text":"<p>An example using the profile format from <code>singlem pipe</code> (see singlem pipe docs):</p> <pre><code>taxburst -F singleM \\\n    examples/SRR11125891.singleM.profile.tsv \\\n    -o pages/SRR11125891.singleM.html\n</code></pre> <p>then open <code>pages/SRR11125891.singleM.html</code> in a browser.</p>"}]}